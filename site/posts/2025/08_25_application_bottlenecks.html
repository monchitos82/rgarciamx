<!doctype html>
<html lang="en" color-scheme="light dark">

<head>
    <!-- Required meta tags -->
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
    <link rel="stylesheet" href="./assets/style.css">

    <title>mon's blog ðŸ‘¾</title>
</head>

<body>
    <div id="content">
        <ul class="menu-bar">
            <li class="menu-item" id="posts">
                <a class="dropdown-btn" href="#" title="Posts">
                    Posts
                </a>
                <div class="dropdown-content">
                    <a class="dropdown-item" href="./posts/2026.html">2026</a>
                    <a class="dropdown-item" href="./posts/2025.html">2025</a>
                    <a class="dropdown-item" href="./posts/2024.html">2024</a>
                </div>
            </li>
        </ul>
        <br />
    </div>
    <h3>Application bottlenecks (08/25)</h3>
    <p>I suck at <em>Java</em>. I have never written production grade <em>Java</em> code. But I have gotten to
        understand the <em>Java</em> virtual machine (<em>JVM</em>), especially because I was mentored by brilliant
        people who understand the language and the virtual machine inside out. I think one of my best opportunities back
        at my previous job was around understanding bottlenecks and tuning a <em>JVM</em>. Tuning a <em>JVM</em> is not
        something we should do out of ignorance though; the <em>JVM</em> defaults are quite effective when dealing with
        regular problems. I will not write a guide on how to profile projects or picking flags to tune the <em>JVM</em>,
        especially when it is something I am not doing on a daily basis, however I wanted to share some advice on
        getting started with profiling and understanding performance from more than a <em>CPU</em> utilization graph
        perspective.</p>
    <p>I should start by mentioning that utilization of resources is not the same as saturation; if you see a
        <em>CPU</em> is being used over 80% that is not an indicator of trouble, quite the contrary, however, if you
        throw in the mix latency concerns and garbage collection, well, your problem (if any) turns interesting.</p>
    <p>One of the things I learned when working with <em>cgroups</em> and old <em>JVM</em> versions is that
        understanding the limits of an application is basically the first and only thing we need to do when fitting a
        process to its assigned resources. There are interesting reads about <em>JVM ergonomics</em> that will suggest
        we want to let the virtual machine handle the hairy parts, and it is correct for the most part of it, yet
        understanding is non trivial when containers are involved. It&rsquo;s also important to understand the
        architecture of a program to figure out how and why it solves a problem the way it does.</p>
    <p>So let&rsquo;s say you have a simple program that scans an array of objects and uses a library to rank them and
        build a recommendation. This sounds like something that would be <em>CPU</em> intensive but manageable, except
        when you run it you notice that latency randomly spikes and you don&rsquo;t see how or why. Looking at logs is
        not effective since you have no errors coming, just latency, then what?</p>
    <p>I dare to say, without hesitation, this was one of my favorite parts of being an <em>SRE</em>. Figuring out
        what&rsquo;s affecting a service and how to push it to perform better is not a one man kind of task, especially
        if you didn&rsquo;t write the code or have access to it for a start. There is a great set of tools at your
        disposal and understanding when to use them is key.</p>
    <ol>
        <li>Graphs - It sounds contradictory to mention graphs just after I said that graphs will not get us somewhere
            in the investigation, however, if well instrumented, graphs are quite useful resources, especially when they
            can overlay. Performance problems (<em>ideally</em>) are non-persistent, but influenced by outstanding
            factors. A graph is a good way to understand when and where the problem starts, yet these are not flawless,
            if instrumentation is poor and there are no good metrics, all we may see are spikes at system levels,
            that&rsquo;s not useful to understand load as a source but as a consequence.</li>
        <li>Profilers - Profiling a process is a good way to understand a few things in a reasonable time window:
            workflows, interruptions, processing load and dependencies to mention a few. When doing this in the
            <em>JVM</em> there is another thing we get to see: the garbage collection (<em>GC</em>). This is very
            important and can be paired with an amazing tool called <em>flamegraphs</em>, we get to see duration of a
            process and the depth of dependencies in a call; this alone may not be very insightful of a problem, but it
            is very insightful on how resources are utilized and helps us gain context on how a program executes and
            what a program is calling. In the example above, you may not see a problem in the graph itself, especially
            when profiling <em>CPU</em> utilization, so how to spot it? I think there are two sensitive ways: a) pay
            attention to the duration of a method execution, is it short some times and very long another? and b) pay
            attention to the <em>GC</em> cadence. Is it suddenly too frequent? Too long? is that graph full of yellow
            bars (or the color scheme you pick for <em>GC</em>)? There is your clue.</li>
        <li>Memory dumps - If you get to understand the flow of a program, you may get to see what is that program doing
            when a problem arises. A memory dump is especially useful when that happens. Having insight on the amount of
            objects, their type and their size is especially useful when detecting a bottleneck. Going back to the
            example above, if your program fails only when scanning objects containing 4K image files when it is
            designed to scan thumbnails, well, it makes sense that your program struggles; but sometimes it is less
            obvious than that, sometimes, it boils down to using objects like boxed numbers or <code>arrayList</code>;
            objects that improve the developer&rsquo;s ergonomics (lazy evaluation) at the expense of memory footprint
            that over time will become wasteful and saturate pages at a staggering speed, sometimes all you have to do
            is go back to using primitives or just correcting the size of a heap because you can&rsquo;t fit objects
            properly. Getting insight on that could be hinted by the profiler, but is not coming until you are at this
            step, then it actually makes sense to think about solutions like tuning the virtual machine or scaling
            vertically.</li>
        <li>Profilers (again!) - I mention profilers again. Just like with overlaying graphs, looking at a program
            behavior under regular circumstances and saturation can be insightful on how the program behaves on the
            latter. Sometimes a <em>flame graph</em> will show it to us right away.</li>
        <li>Source code - I think this is especially useful when we think that our resource allocation is correct and
            that we see that tuning has no effect, why? because performance problems should ideally be solved at the
            code level. Improving our code performance is key on improving our resource utilization, not the other way
            around, most experienced engineers understand this, except that sometimes the re-engineering cost is too
            high, so making room is faster disregard on how ugly it may get.</li>
    </ol>
    <p>This feels like I am just scratching the surface and want to speed run through the topic. I realize this
        conversation is not easy because not everyone starts at the same level and depth into the conversation really
        depends on the problem and the tools. So I would like instead to offer some resources and advice if this is the
        first time you are dealing with something like this:</p>
    <ol>
        <li>Use the <a href="https://sre.google/books/" target="_blank"><em>SRE book</em></a> to get familiar with
            concepts like what has been mentioned here, saturation? observability? it is all in there</li>
        <li>Understanding the <a href="https://docs.oracle.com/en/java/javase/21/gctuning/ergonomics.html"
                target="_blank"><em>JVM ergonomics</em></a> is a good read</li>
        <li>Understanding the <a href="https://docs.oracle.com/en/java/javase/21/gctuning/available-collectors.html"
                target="_blank"><em>GC types of collectors</em></a> and tuning flags is non-trivial but it is one very
            important thing to do. Memory management and <em>GC</em> frequency are <em>knobs</em> that you can play
            with, but ideally you need to understand well first. When in doubt, fall back to the defaults, understand
            the <em>GC</em> periodicity as a necessary sacrifice of performance in exchange of throughput</li>
        <li>Understanding profilers like <a
                href="https://github.com/async-profiler/async-profiler/blob/master/docs/GettingStarted.md"
                target="_blank"><em>async-profiler</em></a> and <a href="https://www.brendangregg.com/flamegraphs.html"
                target="_blank"><em>flamegraphs</em></a>. to me was a great investment of time. I used to advice using
            <strong><em>Minecraft</em></strong> to learn how to do profiling, I still find it quite useful; sadly,
            Mojang has made quite cumbersome understanding the flamegraphs (too much obfuscation in their classes
            nowadays, thank you Microsoft ðŸ˜”).</li>
        <li>Using <a href="https://eclipse.dev/mat/" target="_blank"><em>MAT</em></a> the first time can be
            intimidating, yet it is your best <strong>free</strong> option. I was fortunate enough to get <a
                href="https://jxray.com/" target="_blank"><em>J-Xray</em></a> taught by its author, however it is not a
            free tool. Regardless, you may want to read their blog and articles, that amount of wisdom for free is a
            bargain!</li>
        <li>Understand how to write performant code. Understand the <em>API</em> of your language and
            <strong>never</strong> overlook simplicity</li>
    </ol>
    <p>I think the list above could rapidly grow the more we delve into specifics, my advice, read as you go and try to
        be one step ahead in the knowledge. Many people focus on finding tools to rightsize containers and forget the
        basics like <em>Big-O</em> notation or design principles. This of course is not the end of the conversation, and
        for the sake of brevity I am shying away from discussing off-heap allocation or <em>JNI</em> invocations, but I
        hope you get the gist, we need to look at our performance journey through a funnel:</p>
    <pre>
\=======================================================================/      ---
 \=====================================================================/        |
  \                          Resource definition                      /         Environment adjustments (e.g. full memory allocation) and vertical scaling
   \                         (Container settings)                    /          |
    \---------------------------------------------------------------/          ---
     \                       System metrics                        /            |
      \                      (Monitoring)                         /             |
       \---------------------------------------------------------/              |
        \                    Application configuration          /               |
         \                   (Settings)                        /                |
          \---------------------------------------------------/                 Performance bottlenecks identification
           \                 Application metrics             /                  |
            \                (Monitoring)                   /                   |
             \---------------------------------------------/                    |
              \              CPU utilization &#8635;            /                     |
               \             (Profiling)                 /                      |
                \---------------------------------------/                      ---
                 \           Memory footprint          /                        |
                  \          (Dump analysis)          /                         |
                   \---------------------------------/                          Design and implementation bottlenecks identification and optimizations
                    \        Code analysis          /                           |
                     \                             /                            |
                      \---------------------------/                            ---
                       \     Running environment /                              |
                        \    tuning             /                               JVM and kernel fine tuning
                         \=====================/                                |
                          \===================/                                --- 
</pre>

    <p>Final, and not less important advice I can share: Measure. Load testing and metric analytics are cornerstones of
        a good service health, not paying attention to this, will not spare you the above, but <strong>it will save you
            from executing it with high urgency</strong>.</p>
</body>

</html>